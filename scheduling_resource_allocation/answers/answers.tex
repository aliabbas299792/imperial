\documentclass[fleqn]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}  
\usepackage{graphicx}
\usepackage[a4paper,margin=0.5in,footskip=0.15in]{geometry}

\date{\today}
\author{Ali Abbas}
\title{70068 Scheduling and Resource Allocation CW}

\begin{document}
  \maketitle
  \section{Question 1}
  \subsection{LCL Proof}
  The $Least\ Cost\ Last$ ($LCL$) rule solves the scheduling problem $1 | prec | f_{\text{max}}$ optimally, in $O(n^2)$ time, by constructing
  an optimal schedule from back to front.

  \subsubsection*{Definitions}
  \begin{itemize}
    \item $N = \{ 1, 2, \dots, n \}$ is the index set of all jobs
    \item $L \subseteq N$ is the subset of jobs without successors (which can be scheduled last)
    \item $p(S) = \sum_{j \in S} p_j$ is the total processing time of a subset $S$
    \item $f^*_{\text{max}}(S)$ is the cost of the optimal schedule for subset $S$
    \item $f_{\text{max}}$ denotes the maximum (not necessarly optimal) cost across all jobs in a schedule
    \item $f_j(p(N))$ is a cost function which assigns a penalty/cost depending on job $j$ and the time at which the machine has finished processing, $p(N)$
    \begin{itemize}
      \item In the notation of the coursework specification $g_j(\cdot) = f_j(\cdot)$
      \item In the next section we'll use $g_j(C_j) = T_j = \max(0, C_j - d_j)$ (tardiness)
    \end{itemize}
  \end{itemize}
  \subsubsection*{Proof and Discussion}
  \begin{enumerate}
    \item One job in $L$ must be scheduled last. A job can be
    selected for the final job which minimises $f_j(p(N))$, but it can never result in a cost lower than the cost of the optimal schedule, otherwise that would be the optimal schedule. This is expressed as such: \begin{align*}
      f^*_{\text{max}}(N) \ge \min_{j \in L}f_j (p(N))
    \end{align*}
    \item And removing a job $j \in N$ can't increase the optimal cost any more, since the cost of scheduling a job last is $\ge 0$, so omitting it cannot result in a more expensive schedule: \begin{align*}
      f^*_{\text{max}}(N) \ge f^*_{\text{max}}(N - \{ j \}), \ \forall j \in N
    \end{align*}
    \item We can then select a $J_l \in L$ that minimises $f_j(p(N))$: \begin{align*}
      f_l(p(N)) = \min_{j \in L}f_j(p(N))
    \end{align*}
    Which gives us: \begin{align*}
      f^*_{\text{max}}(N) \ge \max \{ f_l(p(N)), f_{\text{max}}^*(N - \{ l \}) \}
    \end{align*}
    \item The right hand side of the above inequality is the cost of an optimal schedule, where $J_l$ is processed last,
    so you can recursively apply the LCL rule to $N - \{ J_l \}$ and construct a schedule in reverse order
    \begin{itemize}
      \item[-] Since $J_l$ is found in $O(n)$ time, then with $n$, repeated applications of the LCL rule yields the optimal schedule in $O(n^2)$ time
    \end{itemize}
  \end{enumerate}

  You can also show that $LCL$ is optimal by using the \textit{adjacent pairwise interchange argument}:
  \begin{itemize}
    \item You take an optimal schedule $S$ and assume it isn't an $LCL$ schedule
    \item Since it's not an $LCL$ schedule, there must exist at least one pair where a lower cost job precedes a higher cost one
    \item It can then be shown that swapping these jobs yields a lower cost schedule, which is a contradiction since we took an optimal schedule
    \item So by virtue of the fact that a lower cost job can precede a higher cost one leads to a contradiction
    \item And so such pairs cannot exist for an optimal schedule, so we can reject the assumption that this isn't an $LCL$ schedule
    \item And by contradiction then we have that $LCL$ is optimal for $1|prec|f_{\text{max}}$
  \end{itemize}
  
  \subsubsection*{Small Example}
  Example Setup:

    Jobs: J0, J1, J2, J3, J4

    Processing Times: p=[2,3,1,2,3]

    Dude Dates: d=[6,5,7,4,9]

    Precedence Constraints (DAG): J0 $\to$ J1, J0 $\to$ J2, J3 $\to$ J4

    Cost Function: $f_j(C_j) = T_j = max(0, C_j - d_j)$
    
    \paragraph{Iterations}
    We can schedule jobs in reverse order using the $Least\ Cost\ Last$ ($LCL$) rule:
    
    \begin{enumerate}
      \item[0.] Available jobs: $V = \{ 1, 2, 4 \}$ (no successors) \\
      $p(N) = 11$
      \[
      f_{1}(p(N)) = \max(0, 11 - 5) = 6, \quad f_{2}(p(N)) = \max(0, 11 - 4) = 7, \quad f_{4}(p(N)) = \max(0, 11 - 9) = 2
      \]    
      Select $J_{4}$ (minimises $f_j(p(N))$)

      Partial schedule cost: 2

      Updated schedule: $[4]$
        

      \item[1.] Available jobs: $V = \{ 1, 2, 3 \}$ (no successors) \\
      $p(N) = 8$
      \[
      f_{1}(p(N)) = \max(0, 8 - 5) = 3, \quad f_{2}(p(N)) = \max(0, 8 - 4) = 4, \quad f_{3}(p(N)) = \max(0, 8 - 7) = 1
      \]    
      Select $J_{3}$ (minimises $f_j(p(N))$)

      Partial schedule cost: 2

      Updated schedule: $[3, 4]$
        

      \item[2.] Available jobs: $V = \{ 1, 2 \}$ (no successors) \\
      $p(N) = 6$
      \[
      f_{1}(p(N)) = \max(0, 6 - 5) = 1, \quad f_{2}(p(N)) = \max(0, 6 - 4) = 2
      \]    
      Select $J_{1}$ (minimises $f_j(p(N))$)

      Partial schedule cost: 2

      Updated schedule: $[1, 3, 4]$
        

      \item[3.] Available jobs: $V = \{ 2 \}$ (no successors) \\
      $p(N) = 3$
      \[
      f_{2}(p(N)) = \max(0, 3 - 4) = 0
      \]    
      Select $J_{2}$

      Partial schedule cost: 2

      Updated schedule: $[2, 1, 3, 4]$
        

      \item[4.] Available jobs: $V = \{ 0 \}$ (no successors) \\
      $p(N) = 2$
      \[
      f_{0}(p(N)) = \max(0, 2 - 6) = 0
      \]    
      Select $J_{0}$

      Partial schedule cost: 2

      Updated schedule: $[0, 2, 1, 3, 4]$
    \end{enumerate}
    
    \paragraph{Results}
    \begin{itemize}
        \item Final schedule: $[J_0, J_2, J_1, J_3, J_4]$
        \item Completion times:
        \[
        C_0 = 2, \, C_2 = 3, \, C_1 = 6, \, C_3 = 8, \, C_4 = 11
        \]
        \item Tardiness:
        \[
        T_0 = 0, \, T_2 = 0, \, T_1 = 1, \, T_3 = 1, \, T_4 = 2
        \]
        \item Maximum cost:
        \[
        f_{\text{max}} = \max(T_0, T_2, T_1, T_3, T_4) = 2
        \]
    \end{itemize}

    \subsection{LCL Implementation}
    These iterations use 0-based indexing.
    \paragraph{Iterations}
    \begin{enumerate}
      \item[0.] Available jobs: $V = \{ 0, 30 \}$ (no successors) \\
      $p(N) = 170$
      \[
      f_{0}(p(N)) = \max(0, 170 - 172) = 0, \quad f_{30}(p(N)) = \max(0, 170 - 269) = 0
      \]    
      Select $J_{30}$ (minimises $f_j(p(N))$) \\
      Partial schedule cost: 0

      Updated schedule: $[30]$
        

      \item[1.] Available jobs: $V = \{ 0, 1, 10 \}$ (no successors) \\
      $p(N) = 160$
      \[
      f_{0}(p(N)) = \max(0, 160 - 172) = 0, \quad f_{1}(p(N)) = \max(0, 160 - 82) = 78, \quad f_{10}(p(N)) = \max(0, 160 - 253) = 0
      \]    
      Select $J_{0}$ (minimises $f_j(p(N))$) \\
      Partial schedule cost: 0

      Updated schedule: $[0, 30]$

      \item[...]
        

      \item[4.] Available jobs: $V = \{ 1, 4 \}$ (no successors) \\
      $p(N) = 147$
      \[
      f_{1}(p(N)) = \max(0, 147 - 82) = 65, \quad f_{4}(p(N)) = \max(0, 147 - 93) = 54
      \]    
      Select $J_{1}$ (minimises $f_j(p(N))$) \
      Partial schedule cost: 65

      Updated schedule: $[1, 14, 10, 0, 30]$
      
      This iteration was noteable since it incurred the maximum tardiness incurred for this problem.

      \item[...]

      \item[17.] Available jobs: $V = \{ 17, 18, 20, 5 \}$ (no successors) \\
      $p(N) = 68$
      \[
      f_{17}(p(N)) = \max(0, 68 - 77) = 0, \quad f_{18}(p(N)) = \max(0, 68 - 88) = 0,
      \]
      \[
      \quad f_{20}(p(N)) = \max(0, 68 - 71) = 0, \quad f_{5}(p(N)) = \max(0, 68 - 71) = 0
      \] 
      \\   
      Select $J_{17}$ (arbitrarily breaking the tie) \\
      Partial schedule cost: 65

      Updated schedule: $[17, 16, 15, 13, 28, 12, 27, 26, 25, 24, 23, 11, 4, 1, 14, 10, 0, 30]$

      \item[...]

      \item[30.] Available jobs: $V = \{ 29 \}$ (no successors) \\
      $p(N) = 2$
      \[
      f_{29}(p(N)) = \max(0, 2 - 329) = 0
      \]    
      Select $J_{29}$ (minimises $f_j(p(N))$) \\
      Final schedule cost: 65

      Final schedule: $[29, 9, 8, 3, 2, 7, 6, 22, 21, 5, 20, 19, 18, 17, 16, 15, 13, 28, 12, 27, 26, 25, 24, 23, 11, 4, 1, 14, 10, 0, 30]$
    \end{enumerate}

    Note: the tie breaking doesn't specify any ordering in the current implementation (since the set of available jobs is backed by a hash table).

  \subsection{LCL Implementation}

  \section{Question 2}
  \subsection{Tabu Search}

  \subsection{Best Schedule}

\end{document}
